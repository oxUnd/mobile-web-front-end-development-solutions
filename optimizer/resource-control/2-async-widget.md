### 异步模板组件

> 其实SPA也可以用后端渲染模板的方式实现，那种技术叫`Quickling`。

*异步模板组件，以下统称`异步widget`*

移动嘛，不得不说`WebApp`；曾今有一年时间，整个百度前端追逐过这个东西。只是后来效果不是特别好。当初在定义什么是`WebApp`的时候也不是很一致；有一种说法是这样的，单页的Web应用程序即为一个`WebApp`，但比如`贴吧`这样一个产品，做成单页的显然是不可能的，所以后面演化成了有局部刷新而不需要页面`reload`的Web应用。

不管它是什么，有一点是明显的，那就是视觉上看上去就像`Native App`一样。

实现一个`WebApp`，首先想到就是前端MVC，更确切一点就是`backbone`，其实我至今都觉着它提供的`TODO`案例挺玄幻的，用了`玄幻`这个词，意味着它的学习成本还挺高的。

FIS早期的版本就是以`backbone`为主线，实现了第一代的`WebApp`解决方案，使用的产品线挺多，有地图、文库、hao123。

当然很快就发现了问题，但页面展现时间却直逼`10s`，一个页面加载要好几秒才能展示。分析后发现主要原因是多了一个请求数据的过程而且是跟资源请求是串行的，当然当初的打包方案也不太理想，业务逻辑运行需要先把`common`加载过来。

好在后期在不懈的努力中，有了新的突破，使用`Quickling`技术，后端渲染前端拼装的方式解决了性能问题。整体表现很赞，而附带的一个好处就是你可以不用学习`backbone`了。

至于`Quickling`解决方案大概介绍如下；

`Quickling`方案的核心是`异步Widget`，意思是`widget`可以通过前端异步请求。比如后端模板写成了这样；

> widget：FIS组件，页面的一个部分；可能跟你了解的js组件不太相同。我们这块的定义的组件，里面包含模板、js、css和必要的其他资源。

```smarty
...
{%widget name="a.tpl" pagelet_id="A" mode="quickling"%}
...
```

我们就可以用`Ajax`只请求到`a.tpl`的渲染结果，当然包括它依赖的所有资源。

这样的一个好处是，我可以在某一个页面任意请求另一个页面的部分页面（widget），然后渲染到当前页面的任意位置。

这样我们就可以实现`WebApp`了，所谓的一站式站点。

那么，再遇到实现`WebApp`的时候，选择后端渲染的Quickling方案，明显性能方面有优势。再加上目录规范，使用方法跟PC的FIS项目如出一辙，学习成本很低。

综上所述；

- 移动实现一个`WebApp`可选用Quickling方式实现，当然FIS也提供了[Quickling解决方案](https://github.com/xiangshouding/bigpipe.smarty)
- 回顾了下`WebApp`在FIS解决方案上的发展史
- 说明了`Quickling`的核心思想：`异步Widget`